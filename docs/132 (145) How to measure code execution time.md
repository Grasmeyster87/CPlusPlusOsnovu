132(145) Как измерить время выполнения кода

            Отличный вопрос 👍
Разберём **подробно**, что именно означает эта строчка и *чем реально являются* переменные `start` и `end` в коде:

---

### 📘 Строка:

```cpp
std::chrono::time_point<std::chrono::steady_clock> start, end;
```

---

## 🧩 Что такое `std::chrono::time_point`

`std::chrono::time_point` — это **объект**, который хранит **момент времени** (точку на временной шкале).
Но — **сам по себе** он не знает, какой это момент в часах или секундах.
Он всегда связан с конкретным типом часов (`Clock`), например:

* `std::chrono::steady_clock`
* `std::chrono::system_clock`
* `std::chrono::high_resolution_clock`

---

## ⚙️ Что делает `std::chrono::steady_clock`

`steady_clock` — это **часы**, которые:

* всегда идут вперёд (не откатываются назад);
* измеряют **время внутри программы** (не зависит от системных часов пользователя);
* идеально подходят для измерения **длительности выполнения кода**.

---

## 🧠 Что внутри `time_point`

Можно представить так:

```
time_point = точка на шкале steady_clock
```

На самом деле `time_point` хранит одно единственное значение — **смещение (offset)** от "нуля" часов (`steady_clock::now()`), в виде длительности (`duration`).

Например:

```cpp
std::chrono::time_point<std::chrono::steady_clock> start = std::chrono::steady_clock::now();
```

Вот здесь `start` получает текущее значение часов `steady_clock`.
Внутри хранится что-то вроде:

```
внутренное значение = 123456789 наносекунд от старта steady_clock
```

(Это не календарная дата, а просто “счётчик тиков”.)

---

## ⏱ Как это используется

Потом, когда ты берёшь `end`, а затем вычитаешь:

```cpp
auto duration = end - start;
```

Ты получаешь **объект типа** `std::chrono::duration`,
который хранит **разницу во времени** между двумя моментами.

Например:

```cpp
std::chrono::duration<float> duration = end - start;
std::cout << "Duration = " << duration.count() << " s" << std::endl;
```

Тут `.count()` возвращает значение в **секундах** (потому что `duration<float>` измеряется в секундах).

---

## 📊 Какими данными оперирует `time_point`

👉 Это **не контейнер** вроде `vector` или `list`.
Он **не хранит коллекцию** значений, а **одно** — количество тиков (напр. наносекунд) с момента начала отсчёта.

Если сильно упростить — то:

```cpp
std::chrono::time_point<std::chrono::steady_clock>
```

≈

```cpp
long long number_of_nanoseconds_since_start_of_program;
```

---

## 🔧 Пример в действии

```cpp
SimpleTimer::SimpleTimer()
{
    start = chrono::high_resolution_clock::now();
}

SimpleTimer::~SimpleTimer()
{
    end = chrono::high_resolution_clock::now();
    chrono::duration<float> duration = end - start;
    cout << " Duration " << duration.count() << " s " << endl;
}
```

Когда объект создаётся — запоминается момент `start`.
Когда уничтожается (`~SimpleTimer`) — запоминается `end`.
Разница (`end - start`) даёт, сколько времени прошло, пока объект существовал.

---

## 🧩 Итого:

| Элемент                     | Что это                 | Что хранит                          |
| --------------------------- | ----------------------- | ----------------------------------- |
| `std::chrono::steady_clock` | "Тип часов"             | Источник измерения времени          |
| `std::chrono::time_point`   | "Момент времени"        | Смещение от начала отсчёта          |
| `std::chrono::duration`     | "Интервал времени"      | Разницу между двумя точками времени |
| `start`, `end`              | Переменные `time_point` | Моменты начала и конца измерения    |

---

Хочешь, я покажу наглядную “временную шкалу” (ASCII-схему), как `start`, `end` и `duration` связаны между собой?